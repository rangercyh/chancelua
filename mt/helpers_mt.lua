local mt = {}

function mt:capitalize(word)
    return string.upper(string.sub(word, 1, 1)) .. string.sub(word, 2)
end

function mt:mixin()
end
--[[
  Given a function that generates something random and a number of items to generate,
    return an array of items where none repeat.


    @param {Function} fn the function that generates something random
  @param {Number} num number of terms to generate
  @param {Object} options any options to pass on to the generator function
  @returns {Array} an array of length `num` with every item generated by `fn` and unique

  There can be more parameters after these. All additional parameters are provided to the given function
]]
function mt:unique(fn, obj, num, options, ...)
    assert(type(fn) == "function", "Chance: The first argument must be a function.")
    local comparator = function(arr, val)
        for _, v in ipairs(arr) do
            if v == val then
                return true
            end
        end
        return false
    end
    if options then
        comparator = options.comparator or comparator
    end
    local arr, count, max_duplicates = {}, 0, num * 50
    while #arr < num do
        local ret = fn(obj, ...)
        if not(comparator(arr, ret)) then
            arr[#arr + 1] = ret
            -- reset count when unique found
            count = 0
        end
        count = count + 1
        assert(count <= max_duplicates, "Chance: num is likely too large for sample set")
    end
    return arr
end
--[[
  Gives an array of n random terms

  @param {Function} fn the function that generates something random
  @param {Number} n number of terms to generate
  @returns {Array} an array of length `n` with items generated by `fn`

  There can be more parameters after these. All additional parameters are provided to the given function
]]
function mt:n(fn, obj, n, ...)
    assert(type(fn) == "function", "Chance: The first argument must be a function.")
    n = n or 1
    local i, arr = n, {}
    -- Providing a negative count should result in a noop.
    i = math.max(0, i)
    for _ = i, 1, -1 do
        arr[#arr + 1] = fn(obj, ...)
    end
    return arr
end
-- H/T to SO for this one: http://vq.io/OtUrZ5
function mt:pad(number, width, pad)
    -- Default pad to 0 if none provided
    pad = pad or '0'
    -- Convert number to a string
    number = tostring(number)
    return string.rep(pad, width - string.len(number)) .. number
end

-- return a random element from a array or a random slice array
function mt:pick(arr, count)
    assert(#arr > 0, "Chance: Cannot pick() from an empty array")
    if not count or count == 1 then
        return arr[self:natural({ max = #arr })]
    else
        return table.move(self:shuffle(arr), 1, count, 1, {})
    end
end

-- Given an array, returns a single random element
function mt:pickone(arr)
    assert(#arr > 0, "Chance: Cannot pickone() from an empty array")
    return arr[self:natural({ max = #arr })]
end

-- Given an array, returns a random set with 'count' elements
function mt:pickset()
end

function mt:shuffle(t)
    local n = #t
    for i = 1, n do
        local j = self:natural({ max = n })
        t[i], t[j] = t[j], t[i]
    end
    return t
end

-- Returns a single item from an array with relative weighting of odds
function mt:weighted(arr, weights, trim)
    assert(#arr == #weights, "Chance: Length of array and weights must match")
    -- scan weights array and sum valid entries
    local sum = 0
    for i = 1, #weights do
        local val = weights[i]
        assert(type(val) == "number", "Chance: All weights must be numbers")
        if val > 0 then
            sum = sum + val
        end
    end
    assert(sum > 0, "Chance: No valid entries in array weights")
    -- select a value within range
    local selected = self:random() * sum
    -- find array entry corresponding to selected value
    local total = 0
    local chosen_idx
    local last_good_idx = -1
    for i = 1, #weights do
        local val = weights[i]
        total = total + val
        if val > 0 then
            if selected <= total then
                chosen_idx = i
                break
            end
            last_good_idx = i
        end
        -- handle any possible rounding error comparison to ensure something is picked
        if i == #weights then
            chosen_idx = last_good_idx
        end
    end
    local chosen = arr[chosen_idx]
    if trim then
        table.remove(arr, chosen_idx)
        table.remove(weights, chosen_idx)
    end
    return chosen
end

return mt
